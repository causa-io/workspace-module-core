// This file was generated by the Causa command line. Do not edit it manually.

import { AllowMissing, IsNullable } from '@causa/workspace/validation';
import { IsArray, IsIn, IsNumber, IsObject, IsString } from 'class-validator';

/**
 * Additional causa properties used by workspace functions in this package.
 */
export class Causa {
  constructor(init: Causa) {
    Object.assign(this, init);
  }

  /**
   * The directory where project configurations are written by the ProjectWriteConfigurations processor.
   */
  @AllowMissing()
  @IsString()
  readonly projectConfigurationsDirectory?: string;
  [property: string]: any;
}

/**
 * A configuration with additional `causa` properties used by workspace functions in this package.
 */
export class CausaConfiguration {
  constructor(init: CausaConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Additional causa properties used by workspace functions in this package.
   */
  @AllowMissing()
  readonly causa?: Causa;
  [property: string]: any;
}

/**
 * Configuration for the local Docker network.
 */
export class DockerNetwork {
  constructor(init: DockerNetwork) {
    Object.assign(this, init);
  }

  /**
   * The name of the local Docker network.
   */
  @AllowMissing()
  @IsString()
  readonly name?: string;
  [property: string]: any;
}

/**
 * Configuration when using Docker in the workspace.
 */
export class Docker {
  constructor(init: Docker) {
    Object.assign(this, init);
  }

  /**
   * Configuration for the local Docker network.
   */
  @AllowMissing()
  readonly network?: DockerNetwork;
  [property: string]: any;
}

/**
 * The schema for the configuration of Docker.
 */
export class DockerConfiguration {
  constructor(init: DockerConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Configuration when using Docker in the workspace.
   */
  @AllowMissing()
  readonly docker?: Docker;
  [property: string]: any;
}

/**
 * The format to which events are serialized when exchanged through the message broker.
 */
export enum EventsFormat {
  JSON = 'json',
}

/**
 * Defines how topic definitions are found in the workspace.
 */
export class EventsTopics {
  constructor(init: EventsTopics) {
    Object.assign(this, init);
  }

  /**
   * The format string using groups from the regular expression used to make the topic full names.
   */
  @AllowMissing()
  @IsString()
  readonly format?: string;

  /**
   * A list of glob patterns to find topic schema definition files in the workspace.
   */
  @AllowMissing()
  @IsArray()
  @IsString({ each: true })
  readonly globs?: string[];

  /**
   * The regular expression used to extract groups from the topic schemas file paths.
   */
  @AllowMissing()
  @IsString()
  readonly regularExpression?: string;
  [property: string]: any;
}

/**
 * Configuration for events and how they are exchanged between services.
 */
export class Events {
  constructor(init: Events) {
    Object.assign(this, init);
  }

  /**
   * The message broker used to exchange events between services.
   */
  @AllowMissing()
  @IsString()
  readonly broker?: string;

  /**
   * The format to which events are serialized when exchanged through the message broker.
   */
  @AllowMissing()
  @IsIn(['json'])
  readonly format?: EventsFormat;

  /**
   * Defines how topic definitions are found in the workspace.
   */
  @AllowMissing()
  readonly topics?: EventsTopics;
  [property: string]: any;
}

/**
 * Configuration for events.
 */
export class EventsConfiguration {
  constructor(init: EventsConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Configuration for events and how they are exchanged between services.
   */
  @AllowMissing()
  readonly events?: Events;
  [property: string]: any;
}

export class ProcessorInstruction {
  constructor(init: ProcessorInstruction) {
    Object.assign(this, init);
  }

  /**
   * Arguments for the workspace function.
   */
  @AllowMissing()
  @IsObject()
  readonly args?: { [key: string]: any };

  /**
   * The name of the WorkspaceFunction.
   */
  @IsString()
  readonly name!: string;
  [property: string]: any;
}

/**
 * Configuration for infrastructure projects.
 */
export class Infrastructure {
  constructor(init: Infrastructure) {
    Object.assign(this, init);
  }

  /**
   * The location of the project, relative to the workspace root, that defines the infrastructure for a single environment.
   */
  @AllowMissing()
  @IsString()
  readonly environmentProject?: string;

  /**
   * The list of processors that should be run prior to infrastructure operations to set up the workspace.
   * Processors should implement the `InfrastructureProcessor` interface.
   */
  @AllowMissing()
  @IsArray()
  readonly processors?: ProcessorInstruction[];

  /**
   * Variables to be passed to the infrastructure as code system (e.g.  Terraform).
   * Supports rendering.
   */
  @AllowMissing()
  @IsObject()
  readonly variables?: { [key: string]: string };
  [property: string]: any;
}

/**
 * Configuration for infrastructure projects.
 */
export class InfrastructureConfiguration {
  constructor(init: InfrastructureConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Configuration for infrastructure projects.
   */
  @AllowMissing()
  readonly infrastructure?: Infrastructure;
  [property: string]: any;
}

export class CodeGenerator {
  constructor(init: CodeGenerator) {
    Object.assign(this, init);
  }

  /**
   * The name of the generator to run.
   */
  @IsString()
  readonly generator!: string;
  [property: string]: any;
}

/**
 * The schema format in which the model is defined.
 */
export enum ModelSchema {
  Jsonschema = 'jsonschema',
}

/**
 * Configuration for the business model definitions.
 */
export class Model {
  constructor(init: Model) {
    Object.assign(this, init);
  }

  /**
   * A list of code generators to run in a project when the `model generateCode` command is run.
   */
  @AllowMissing()
  @IsArray()
  readonly codeGenerators?: CodeGenerator[];

  /**
   * The schema format in which the model is defined.
   */
  @AllowMissing()
  @IsIn(['jsonschema'])
  readonly schema?: ModelSchema;
  [property: string]: any;
}

export class ModelConfiguration {
  constructor(init: ModelConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Configuration for the business model definitions.
   */
  @AllowMissing()
  readonly model?: Model;
  [property: string]: any;
}

/**
 * Configuration for OpenAPI specifications-related operations.
 */
export class OpenAPI {
  constructor(init: OpenAPI) {
    Object.assign(this, init);
  }

  /**
   * An OpenAPI specification file to be used as the base when generating the specification for the entire workspace.
   */
  @AllowMissing()
  @IsObject()
  readonly global?: { [key: string]: any };

  /**
   * If set, the list of servers will be generated using a value from the configuration of each environment.
   * This should be the path to the configuration property containing the server URL.
   */
  @AllowMissing()
  @IsString()
  readonly serversFromEnvironmentConfiguration?: string;

  /**
   * A list of glob patterns matching OpenAPI specification files to merge when generating the specification for a project.
   * The globs are resolved relative to the project directory.
   */
  @AllowMissing()
  @IsArray()
  @IsString({ each: true })
  readonly specifications?: string[];
  [property: string]: any;
}

/**
 * Configuration for OpenAPI specifications-related operations.
 */
export class OpenAPIConfiguration {
  constructor(init: OpenAPIConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Configuration for OpenAPI specifications-related operations.
   */
  @IsNullable()
  @AllowMissing()
  readonly openApi?: null | OpenAPI;
  [property: string]: any;
}

/**
 * Configuration when building the artefact for serverless functions projects.
 */
export class ServerlessFunctionsBuild {
  constructor(init: ServerlessFunctionsBuild) {
    Object.assign(this, init);
  }

  /**
   * The glob patterns to include when building the artefact.
   * Language-specific modules may already include patterns by default, check their documentation before adding other patterns.
   */
  @AllowMissing()
  @IsArray()
  @IsString({ each: true })
  readonly globPatterns?: string[];
  [property: string]: any;
}

/**
 * The data the function produces.
 */
export class ServerlessFunctionOutputs {
  constructor(init: ServerlessFunctionOutputs) {
    Object.assign(this, init);
  }

  /**
   * The list of event topics to which this function can publish events.
   */
  @AllowMissing()
  @IsArray()
  @IsString({ each: true })
  readonly eventTopics?: string[];
  [property: string]: any;
}

/**
 * The event that triggers the function.
 */
export class ServerlessFunctionTrigger {
  constructor(init: ServerlessFunctionTrigger) {
    Object.assign(this, init);
  }

  /**
   * The type of trigger.
   */
  @IsString()
  readonly type!: string;

  /**
   * The ID of the topic triggering the endpoint.
   */
  @AllowMissing()
  @IsString()
  readonly topic?: string;
  [property: string]: any;
}

export class ServerlessFunction {
  constructor(init: ServerlessFunction) {
    Object.assign(this, init);
  }

  /**
   * The description of the function.
   */
  @AllowMissing()
  @IsString()
  readonly description?: string;

  /**
   * The name of the function in the package.
   */
  @IsString()
  readonly entrypoint!: string;

  /**
   * The data the function produces.
   */
  @AllowMissing()
  readonly outputs?: ServerlessFunctionOutputs;

  /**
   * The event that triggers the function.
   */
  readonly trigger!: ServerlessFunctionTrigger;
  [property: string]: any;
}

/**
 * Configuration for serverless functions projects, i.e. packages exposing functions that are deployed by a serverless platform.
 */
export class ServerlessFunctions {
  constructor(init: ServerlessFunctions) {
    Object.assign(this, init);
  }

  /**
   * Configuration when building the artefact for serverless functions projects.
   */
  @AllowMissing()
  readonly build?: ServerlessFunctionsBuild;

  /**
   * The list of functions exposed by this project.
   */
  @AllowMissing()
  @IsObject()
  readonly functions?: { [key: string]: ServerlessFunction };

  /**
   * The service managing the serverless functions (Google Cloud Functions, AWS Lambda, etc).
   */
  @AllowMissing()
  @IsString()
  readonly platform?: string;
  [property: string]: any;
}

/**
 * Configuration for serverless functions projects (Google Cloud Functions, AWS Lambda, etc).
 */
export class ServerlessFunctionsConfiguration {
  constructor(init: ServerlessFunctionsConfiguration) {
    Object.assign(this, init);
  }

  /**
   * Configuration for serverless functions projects, i.e. packages exposing functions that are deployed by a serverless platform.
   */
  @AllowMissing()
  readonly serverlessFunctions?: ServerlessFunctions;
  [property: string]: any;
}

export class Project {
  constructor(init: Project) {
    Object.assign(this, init);
  }

  /**
   * The deployed version of the service, which should correspond to a version tag in the container registry.
   */
  @AllowMissing()
  @IsString()
  readonly activeVersion?: string;
  [property: string]: any;
}

export class BuildSecret {
  constructor(init: BuildSecret) {
    Object.assign(this, init);
  }

  /**
   * The source file for the secret.
   */
  @AllowMissing()
  @IsString()
  readonly file?: string;

  /**
   * The value of the secret.
   * In this case the value will be passed as an environment variable to the Docker command.
   */
  @AllowMissing()
  @IsString()
  readonly value?: string;
  [property: string]: any;
}

/**
 * The endpoints exposed by the service.
 */
export class ServiceContainerEndpoints {
  constructor(init: ServiceContainerEndpoints) {
    Object.assign(this, init);
  }

  /**
   * The HTTP endpoints exposed by the service.
   */
  @AllowMissing()
  @IsArray()
  @IsString({ each: true })
  readonly http?: string[];
  [property: string]: any;
}

/**
 * The data this service produces.
 */
export class ServiceContainerOutputs {
  constructor(init: ServiceContainerOutputs) {
    Object.assign(this, init);
  }

  /**
   * The list of event topics to which this service can publish events.
   */
  @AllowMissing()
  @IsArray()
  @IsString({ each: true })
  readonly eventTopics?: string[];
  [property: string]: any;
}

/**
 * The endpoint called by the trigger.
 */
export class ServiceContainerTriggerEndpoint {
  constructor(init: ServiceContainerTriggerEndpoint) {
    Object.assign(this, init);
  }

  /**
   * The path of the endpoint.
   */
  @IsString()
  readonly path!: string;

  /**
   * The type of endpoint.
   */
  @IsString()
  readonly type!: string;
  [property: string]: any;
}

export class ServiceContainerTrigger {
  constructor(init: ServiceContainerTrigger) {
    Object.assign(this, init);
  }

  /**
   * The endpoint called by the trigger.
   */
  @AllowMissing()
  readonly endpoint?: ServiceContainerTriggerEndpoint;

  /**
   * The type of trigger.
   */
  @IsString()
  readonly type!: string;

  /**
   * The ID of the topic triggering the endpoint.
   */
  @AllowMissing()
  @IsString()
  readonly topic?: string;

  /**
   * The cron schedule expression for cron triggers.
   */
  @AllowMissing()
  @IsString()
  readonly schedule?: string;

  /**
   * The timezone for the cron schedule.
   */
  @AllowMissing()
  @IsString()
  readonly timezone?: string;

  /**
   * The name of the queue for task triggers.
   */
  @AllowMissing()
  @IsString()
  readonly queue?: string;
  [property: string]: any;
}

/**
 * Configuration for service container projects, i.e. services that are run as generic Docker containers.
 */
export class ServiceContainer {
  constructor(init: ServiceContainer) {
    Object.assign(this, init);
  }

  /**
   * The processor architecture used when building (and running) Docker images for the service.
   */
  @AllowMissing()
  @IsString()
  readonly architecture?: string;

  /**
   * Docker build arguments when building the image for the service.
   * Supports rendering.
   */
  @AllowMissing()
  @IsObject()
  readonly buildArgs?: { [key: string]: string };

  /**
   * The Dockerfile used to build the image for the service.
   * Language-specific modules may provide a default value for this.
   */
  @AllowMissing()
  @IsString()
  readonly buildFile?: string;

  /**
   * Docker build --secret arguments to pass when building the image for the service.
   * Supports rendering.
   */
  @AllowMissing()
  @IsObject()
  readonly buildSecrets?: { [key: string]: BuildSecret };

  /**
   * The maximum CPU allowed to the container, as a "quantity" Kubernetes type.
   */
  @AllowMissing()
  @IsString()
  readonly cpuLimit?: string;

  /**
   * The endpoints exposed by the service.
   */
  @AllowMissing()
  readonly endpoints?: ServiceContainerEndpoints;

  /**
   * The environment variables passed to the service.
   */
  @AllowMissing()
  @IsObject()
  readonly environmentVariables?: { [key: string]: string };

  /**
   * The maximum number of instances of the service that should be running.
   */
  @AllowMissing()
  @IsNumber()
  readonly maxInstances?: number;

  /**
   * The maximum memory allowed to the container, as a "quantity" Kubernetes type.
   */
  @AllowMissing()
  @IsString()
  readonly memoryLimit?: string;

  /**
   * The minimum number of instances of the service that should be running.
   */
  @AllowMissing()
  @IsNumber()
  readonly minInstances?: number;

  /**
   * The data this service produces.
   */
  @AllowMissing()
  readonly outputs?: ServiceContainerOutputs;

  /**
   * The platform / orchestrator on which the service is deployed.
   */
  @AllowMissing()
  @IsString()
  readonly platform?: string;

  /**
   * A map of triggers that call the service's endpoints when they occur.
   */
  @AllowMissing()
  @IsObject()
  readonly triggers?: { [key: string]: ServiceContainerTrigger };
  [property: string]: any;
}

/**
 * Configuration for service container projects.
 */
export class ServiceContainerConfiguration {
  constructor(init: ServiceContainerConfiguration) {
    Object.assign(this, init);
  }

  @AllowMissing()
  readonly project?: Project;

  /**
   * Configuration for service container projects, i.e. services that are run as generic Docker containers.
   */
  @AllowMissing()
  readonly serviceContainer?: ServiceContainer;
  [property: string]: any;
}
