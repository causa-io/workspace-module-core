import {
  FetchingJSONSchemaStore,
  InputData,
  JSONSchemaInput,
  JSONSchemaStore,
  quicktype,
  QuickTypeError,
  TypeScriptTargetLanguage,
  type JSONSchemaSourceData,
} from 'quicktype-core';
import { causaJsonSchemaAttributeProducer } from './jsonschema-attribute-producer.js';
import { AbsoluteIdJsonSchemaStore } from './schema-store.js';
import type { TargetLanguageWithWriter } from './target-language-with-writer.js';

/**
 * The properties in JSONSchema files for which nested schemas are generated by default.
 */
const DEFAULT_NESTED_SCHEMAS = ['$defs', 'definitions'];

/**
 * Constructs an {@link InputData} object that lists JSONSchema files, which can be used by
 * {@link generateCodeForSchemas}.
 *
 * @param sources The {@link JSONSchemaSourceData} to include in the input data.
 * @param options Options for the input data.
 * @returns The {@link InputData} object that can be passed to {@link generateCodeForSchemas}.
 */
export async function makeJsonSchemaInputDataFromSources(
  sources: JSONSchemaSourceData[],
  options: {
    /**
     * The JSONSchema store to use for fetching schemas. If not provided, a new {@link FetchingJSONSchemaStore} will be
     * created.
     */
    schemaStore?: JSONSchemaStore;
  } = {},
): Promise<InputData> {
  const store = options.schemaStore ?? new FetchingJSONSchemaStore();
  const input = new JSONSchemaInput(store, [causaJsonSchemaAttributeProducer]);

  for (const source of sources) {
    await input.addSource(source);
  }

  const inputData = new InputData();
  inputData.addInput(input);

  return inputData;
}

/**
 * Constructs an {@link InputData} object that lists and parses JSONSchema files, possibly including nested schemas and
 * indirectly referenced schemas.
 *
 * This works by running `quicktype` a first time only on the provided files, in order to parse the JSONSchemas and
 * resolve all references. Then, a new {@link InputData} is created according to the provided `options`, possibly
 * including nested schemas and resolved references.
 *
 * @param files The list of JSONSchema files to parse and include in the input data.
 * @param options Options when parsing the JSONSchema files.
 * @returns The {@link InputData} object that can be passed to {@link generateCodeForSchemas}.
 */
export async function makeJsonSchemaInputData(
  files: string[],
  options: {
    /**
     * A list of properties that may exist in JSONSchema files and contain nested schemas. If present, the nested
     * schemas will be included in the input data and generated.
     * Defaults to '$defs' and 'definitions'.
     */
    nestedSchemas?: string[];

    /**
     * If `true`, JSONSchema files that are referenced by other schemas will be included in the input data, along with
     * their nested schemas. This means that not just the referenced schemas will be generated, but also all schemas
     * present in the referenced files.
     * Defaults to `true`.
     */
    includeFullReferences?: boolean;
  } = {},
): Promise<InputData> {
  const nestedSchemas = options.nestedSchemas ?? DEFAULT_NESTED_SCHEMAS;
  const includeReferences = options.includeFullReferences ?? true;

  // This schema store will be used twice: for the initial parsing of the schemas, and when creating the final input
  // data. Not only the store is used after the first run to resolve references, but this also avoids having to
  // re-fetch the schemas from the files.
  const schemaStore = new AbsoluteIdJsonSchemaStore();
  // There is an inconsistent behavior in naming when passing a single schema file to quicktype.
  // Setting the name as `undefined` ensures the `title` JSONSchema attribute is used as the class name for the
  // top-level type in the schema.
  const name: any = undefined;

  const rawSources = files.map((f) => ({ name, uris: [f] }));
  const rawInputData = await makeJsonSchemaInputDataFromSources(rawSources, {
    schemaStore,
  });
  await quicktype({
    inputData: rawInputData,
    // This could be any language, generation will not actually occur.
    lang: new TypeScriptTargetLanguage(),
    noRender: true,
  });

  const sourcesWithReferencesAndNestedSchemas = Object.entries(
    schemaStore.absolutePathSchemas,
  ).flatMap(([file, schema]) => {
    if (!files.includes(file) && !includeReferences) {
      return [];
    }

    const fileSources: JSONSchemaSourceData[] = [{ name, uris: [file] }];
    if (typeof schema === 'boolean') {
      return fileSources;
    }

    nestedSchemas
      .filter((p) => typeof schema[p] === 'object')
      .forEach((nestedSchema) =>
        fileSources.unshift({ name, uris: [`${file}#/${nestedSchema}/`] }),
      );

    return fileSources;
  });

  return await makeJsonSchemaInputDataFromSources(
    sourcesWithReferencesAndNestedSchemas,
    { schemaStore },
  );
}

/**
 * Generates the code for the given schemas using the provided target language, and writes it to the configured file.
 *
 * @param lang The target language used to generate code.
 * @param inputData The {@link InputData} referencing the schemas.
 */
export async function generateCodeForSchemas(
  lang: TargetLanguageWithWriter,
  inputData: InputData,
): Promise<void> {
  try {
    const result = await quicktype({ inputData, lang });
    const outputLines = result.lines.join('\n');
    await lang.writeFile(outputLines);
  } catch (error) {
    if (error instanceof QuickTypeError) {
      throw new Error(error.properties['message'] ?? error.message);
    }

    throw error;
  }
}
